# Data Model: History View - Previous Optimizations

**Feature**: 005-history-view-previous
**Date**: 2025-10-13
**Phase**: Phase 1 - Design

## Overview

The History View feature leverages existing database tables with NO schema changes required. This document defines the data model for the history view, including query patterns, computed properties, and relationships.

## Database Schema (Existing - No Changes)

### Primary Tables

#### `optimizations` (Existing)
```sql
CREATE TABLE optimizations (
  id                BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id           UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  resume_id         BIGINT NOT NULL REFERENCES resumes(id) ON DELETE CASCADE,
  jd_id             BIGINT NOT NULL REFERENCES job_descriptions(id) ON DELETE CASCADE,
  match_score       REAL NULL,
  gaps_json         JSONB NULL,
  rewrite_json      JSONB NULL,
  template_key      TEXT NULL,
  output_paths      JSONB NULL,
  status            TEXT NULL,
  created_at        TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

-- Existing RLS Policies (enforced automatically)
CREATE POLICY "Users can read own optimizations"
  ON optimizations FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own optimizations"
  ON optimizations FOR DELETE
  USING (auth.uid() = user_id);
```

#### `job_descriptions` (Existing)
```sql
CREATE TABLE job_descriptions (
  id                BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id           UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  source_url        TEXT NULL,
  title             TEXT NULL,
  company           TEXT NULL,
  raw_text          TEXT NULL,
  clean_text        TEXT NULL,
  extracted_json    JSONB NULL,
  embeddings        VECTOR NULL,
  created_at        TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);
```

#### `applications` (Existing)
```sql
CREATE TABLE applications (
  id                BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id           UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  optimization_id   BIGINT NOT NULL REFERENCES optimizations(id) ON DELETE CASCADE,
  job_title         TEXT NOT NULL,
  company_name      TEXT NOT NULL,
  job_url           TEXT NULL,
  status            TEXT NOT NULL DEFAULT 'saved',
  applied_date      TIMESTAMP WITH TIME ZONE NULL,
  contact_person    TEXT NULL,
  notes             TEXT NULL,
  created_at        TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  updated_at        TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);
```

## New Indexes (Performance Optimization)

```sql
-- Optimize user + date sorting (primary history query)
CREATE INDEX IF NOT EXISTS idx_optimizations_user_created
  ON optimizations(user_id, created_at DESC);

-- Optimize score filtering
CREATE INDEX IF NOT EXISTS idx_optimizations_score
  ON optimizations(match_score)
  WHERE match_score IS NOT NULL;

-- Optional: Full-text search on job descriptions (if implemented)
CREATE INDEX IF NOT EXISTS idx_jd_title_company_search
  ON job_descriptions
  USING gin(to_tsvector('english', COALESCE(title, '') || ' ' || COALESCE(company, '')));
```

## TypeScript Type Definitions

### API Types

```typescript
/**
 * Query parameters for GET /api/optimizations
 */
export interface OptimizationsQueryParams {
  /** Page number (1-indexed) */
  page?: number;

  /** Items per page (default: 20, max: 100) */
  limit?: number;

  /** Sort field */
  sort?: 'date' | 'score' | 'company';

  /** Sort direction */
  order?: 'asc' | 'desc';

  /** Filter by date range (ISO 8601) */
  dateFrom?: string;
  dateTo?: string;

  /** Filter by minimum match score (0-1) */
  minScore?: number;

  /** Search query for job title/company */
  search?: string;
}

/**
 * Response from GET /api/optimizations
 */
export interface OptimizationsResponse {
  success: boolean;
  optimizations: OptimizationHistoryEntry[];
  pagination: PaginationMeta;
}

/**
 * Single optimization entry in history view
 */
export interface OptimizationHistoryEntry {
  /** Optimization ID */
  id: number;

  /** Creation timestamp */
  createdAt: string; // ISO 8601

  /** Job title from job description */
  jobTitle: string | null;

  /** Company name from job description */
  company: string | null;

  /** ATS match score (0-1) */
  matchScore: number;

  /** Optimization status */
  status: string;

  /** Source job posting URL */
  jobUrl: string | null;

  /** Template key used */
  templateKey: string | null;

  /** Whether this optimization has been applied to */
  hasApplication: boolean;

  /** Application status if exists */
  applicationStatus?: ApplicationStatus;

  /** Applied date if exists */
  applicationDate?: string; // ISO 8601

  /** Application ID if exists */
  applicationId?: number;
}

/**
 * Pagination metadata
 */
export interface PaginationMeta {
  /** Current page (1-indexed) */
  page: number;

  /** Items per page */
  limit: number;

  /** Total items matching filters */
  total: number;

  /** Whether more pages exist */
  hasMore: boolean;

  /** Total pages */
  totalPages: number;
}

/**
 * Application status enum
 */
export type ApplicationStatus =
  | 'saved'
  | 'applied'
  | 'interviewing'
  | 'offer'
  | 'rejected'
  | 'withdrawn';

/**
 * Bulk delete request
 */
export interface BulkDeleteRequest {
  /** IDs to delete */
  ids: number[];
}

/**
 * Bulk delete response
 */
export interface BulkDeleteResponse {
  success: boolean;
  deleted: number;
  errors?: { id: number; error: string }[];
  preserved: {
    /** Applications preserved (not deleted) */
    applications: number;
  };
}

/**
 * Bulk export request
 */
export interface BulkExportRequest {
  /** IDs to export */
  ids: number[];

  /** Optional: include metadata manifest */
  includeManifest?: boolean;
}
```

### Frontend State Types

```typescript
/**
 * History page state management
 */
export interface HistoryPageState {
  // Data
  optimizations: OptimizationHistoryEntry[];
  selectedIds: Set<number>;

  // Filters
  filters: HistoryFilters;

  // Pagination
  pagination: PaginationMeta;

  // UI State
  isLoading: boolean;
  error: string | null;
  sortConfig: SortConfig;

  // Bulk operations
  bulkOperation: BulkOperationState | null;
}

/**
 * Filter state
 */
export interface HistoryFilters {
  /** Search text for job title/company */
  search: string;

  /** Date range filter */
  dateRange: {
    from: Date;
    to: Date;
  } | null;

  /** Minimum match score (0-100 percentage) */
  minScore: number | null;
}

/**
 * Sort configuration
 */
export interface SortConfig {
  column: 'date' | 'score' | 'company';
  direction: 'asc' | 'desc';
}

/**
 * Bulk operation state
 */
export interface BulkOperationState {
  type: 'delete' | 'export';
  isProcessing: boolean;
  progress?: {
    current: number;
    total: number;
  };
}

/**
 * Table row action result
 */
export interface RowActionResult {
  success: boolean;
  action: 'view' | 'download' | 'apply';
  optimizationId: number;
  error?: string;
}
```

## Query Patterns

### 1. Fetch History (Base Query)

**SQL (via Supabase)**:
```typescript
const query = supabase
  .from('optimizations')
  .select(`
    id,
    created_at,
    match_score,
    status,
    template_key,
    job_descriptions!jd_id (
      id,
      title,
      company,
      source_url
    ),
    applications (
      id,
      status,
      applied_date
    )
  `)
  .eq('user_id', user.id)
  .order('created_at', { ascending: false });
```

**Estimated Performance**:
- Without index: 200-500ms for 100 records
- With index: 50-150ms for 100 records
- Meets SC-001 requirement (<2s)

### 2. Fetch History with Filters

```typescript
// Base query (same as above)
let query = baseQuery;

// Date range filter
if (dateFrom && dateTo) {
  query = query
    .gte('created_at', dateFrom)
    .lte('created_at', dateTo);
}

// Score filter
if (minScore) {
  query = query.gte('match_score', minScore);
}

// Pagination
const offset = (page - 1) * limit;
query = query.range(offset, offset + limit - 1);

// Search (client-side post-processing)
// Note: Search is done client-side to avoid complex full-text search setup
// If performance becomes an issue, upgrade to PostgreSQL full-text search
```

### 3. Check Application Status (Used for "Applied" Badge)

```typescript
// Already included in main query via LEFT JOIN
// No additional query needed
```

### 4. Bulk Delete with Cascade Protection

```typescript
// Transaction pattern
const { data: optimizations, error } = await supabase
  .from('optimizations')
  .delete()
  .in('id', ids)
  .eq('user_id', user.id) // RLS enforcement
  .select();

// Applications are preserved via CASCADE policy
// Frontend displays warning in confirmation dialog
```

## Computed Properties

### Days Since Created
**Client-side calculation**:
```typescript
function daysSinceCreated(createdAt: string): number {
  const created = new Date(createdAt);
  const now = new Date();
  const diffMs = now.getTime() - created.getTime();
  return Math.floor(diffMs / (1000 * 60 * 60 * 24));
}
```

### Has Application
**Determined by join**:
```typescript
const hasApplication = entry.applications && entry.applications.length > 0;
```

### Match Score Percentage
**Client-side formatting**:
```typescript
function formatMatchScore(score: number): string {
  return `${Math.round(score * 100)}%`;
}
```

### Application Status Badge
**Client-side rendering**:
```typescript
function getApplicationBadge(entry: OptimizationHistoryEntry) {
  if (!entry.hasApplication) return null;

  return {
    label: entry.applicationStatus || 'Applied',
    variant: getStatusVariant(entry.applicationStatus),
    date: entry.applicationDate,
  };
}
```

## Data Flow Diagrams

### 1. Page Load Flow
```
User navigates to /dashboard/history
  ↓
Page component mounts
  ↓
useEffect triggers data fetch
  ↓
GET /api/optimizations (with default params)
  ↓
Supabase query with RLS
  ↓
Join optimizations + job_descriptions + applications
  ↓
Apply server-side filters (date, score)
  ↓
Return paginated results
  ↓
Client receives data
  ↓
Apply client-side filters (search)
  ↓
Render table with loading → data transition
```

### 2. Filter Change Flow
```
User types in search box
  ↓
Debounce 300ms
  ↓
Update filter state
  ↓
Update URL search params (for bookmarking)
  ↓
Trigger re-fetch if server-side filter changed
  OR
  Apply client-side filter if search-only
  ↓
Update table with new results
```

### 3. Apply Now Flow (from History)
```
User clicks "Apply Now" on row
  ↓
Extract optimization data
  ↓
Trigger apply flow:
  1. POST /api/applications (create record)
  2. GET /api/download/[id] (generate PDF)
  3. window.open(jobUrl) (if available)
  ↓
Show success toast
  ↓
Update row state (show "Applied" badge)
  ↓
Update selectedIds if needed
```

### 4. Bulk Delete Flow
```
User selects multiple rows
  ↓
User clicks "Delete Selected"
  ↓
Show confirmation dialog (count + warning)
  ↓
User confirms
  ↓
DELETE /api/optimizations/bulk
  ↓
Supabase deletes with RLS check
  ↓
Return deleted count + preserved applications
  ↓
Remove rows from table
  ↓
Show success toast with details
  ↓
Clear selection
```

## Validation Rules

### Query Parameters
```typescript
/**
 * Validate and sanitize query parameters
 */
function validateQueryParams(params: OptimizationsQueryParams): ValidationResult {
  const errors: string[] = [];

  // Page validation
  if (params.page !== undefined) {
    if (params.page < 1 || !Number.isInteger(params.page)) {
      errors.push('page must be a positive integer');
    }
  }

  // Limit validation
  if (params.limit !== undefined) {
    if (params.limit < 1 || params.limit > 100 || !Number.isInteger(params.limit)) {
      errors.push('limit must be between 1 and 100');
    }
  }

  // Date validation
  if (params.dateFrom && !isValidISODate(params.dateFrom)) {
    errors.push('dateFrom must be a valid ISO 8601 date');
  }
  if (params.dateTo && !isValidISODate(params.dateTo)) {
    errors.push('dateTo must be a valid ISO 8601 date');
  }
  if (params.dateFrom && params.dateTo && new Date(params.dateFrom) > new Date(params.dateTo)) {
    errors.push('dateFrom must be before dateTo');
  }

  // Score validation
  if (params.minScore !== undefined) {
    if (params.minScore < 0 || params.minScore > 1) {
      errors.push('minScore must be between 0 and 1');
    }
  }

  // Search validation
  if (params.search !== undefined) {
    const sanitized = sanitizeSearchQuery(params.search);
    if (sanitized.length > 100) {
      errors.push('search query must be 100 characters or less');
    }
  }

  return {
    valid: errors.length === 0,
    errors,
    sanitized: sanitizeParams(params),
  };
}
```

### Bulk Operation Validation
```typescript
/**
 * Validate bulk operation requests
 */
function validateBulkRequest(ids: number[]): ValidationResult {
  const errors: string[] = [];

  if (!Array.isArray(ids)) {
    errors.push('ids must be an array');
  }

  if (ids.length === 0) {
    errors.push('ids array cannot be empty');
  }

  if (ids.length > 50) {
    errors.push('cannot operate on more than 50 items at once');
  }

  if (!ids.every(id => Number.isInteger(id) && id > 0)) {
    errors.push('all ids must be positive integers');
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}
```

## Error Handling

### Database Errors
```typescript
type DatabaseError =
  | 'RLS_VIOLATION'         // User trying to access others' data
  | 'NOT_FOUND'             // Optimization doesn't exist
  | 'FOREIGN_KEY_VIOLATION' // Referenced record doesn't exist
  | 'CONNECTION_ERROR'      // Database connection failed
  | 'TIMEOUT'               // Query took too long

function handleDatabaseError(error: PostgrestError): ErrorResponse {
  switch (error.code) {
    case '42501': // RLS violation
      return { status: 403, message: 'Access denied' };

    case '23503': // Foreign key violation
      return { status: 404, message: 'Referenced record not found' };

    default:
      return { status: 500, message: 'Database error occurred' };
  }
}
```

### API Errors
```typescript
type APIError =
  | 'INVALID_PARAMS'    // Query params validation failed
  | 'UNAUTHORIZED'      // No auth token
  | 'FORBIDDEN'         // Auth token valid but access denied
  | 'NOT_FOUND'         // Resource doesn't exist
  | 'RATE_LIMITED'      // Too many requests
  | 'SERVER_ERROR';     // Internal error

interface ErrorResponse {
  success: false;
  error: string;
  details?: string;
  code: APIError;
}
```

## Caching Strategy

### Client-Side Caching
```typescript
/**
 * Cache configuration for React Query / SWR
 */
const CACHE_CONFIG = {
  // Keep data fresh for 5 minutes
  staleTime: 5 * 60 * 1000,

  // Cache for 10 minutes
  cacheTime: 10 * 60 * 1000,

  // Refetch on window focus
  refetchOnWindowFocus: true,

  // Don't refetch on mount if data is fresh
  refetchOnMount: false,
};
```

### URL State Synchronization
```typescript
/**
 * Sync filters with URL for bookmarking
 */
function useURLState() {
  const router = useRouter();
  const searchParams = useSearchParams();

  const updateURL = (filters: HistoryFilters, pagination: PaginationMeta) => {
    const params = new URLSearchParams();

    if (filters.search) params.set('search', filters.search);
    if (filters.minScore) params.set('minScore', filters.minScore.toString());
    if (filters.dateRange) {
      params.set('dateFrom', filters.dateRange.from.toISOString());
      params.set('dateTo', filters.dateRange.to.toISOString());
    }
    if (pagination.page > 1) params.set('page', pagination.page.toString());

    router.push(`/dashboard/history?${params.toString()}`, { scroll: false });
  };

  return { updateURL };
}
```

## Performance Characteristics

### Query Performance Targets
| Operation | Target | With Indexes | Without Indexes |
|-----------|--------|--------------|-----------------|
| Fetch 20 items | <500ms | <100ms | <300ms |
| Fetch 100 items | <2s | <200ms | <1s |
| Search filter | <200ms | N/A (client) | N/A (client) |
| Date filter | <500ms | <100ms | <400ms |
| Score filter | <500ms | <150ms | <400ms |
| Bulk delete (50) | <5s | <2s | <4s |

### Scalability Limits
- **Free Tier**: Up to 1,000 optimizations per user
- **Paid Tier**: Unlimited (with pagination)
- **Query Limit**: Max 100 items per request
- **Bulk Limit**: Max 50 items per operation

## Migration Path

### Phase 1: Immediate (No Migration)
- Use existing schema as-is
- No data migration required
- Add indexes via SQL script (non-blocking)

### Phase 2: Optional Enhancements
If performance degrades with large datasets:

1. **Add Materialized View** (cached query results):
```sql
CREATE MATERIALIZED VIEW optimization_history_view AS
SELECT
  o.id,
  o.user_id,
  o.created_at,
  o.match_score,
  o.status,
  jd.title,
  jd.company,
  jd.source_url,
  EXISTS (
    SELECT 1 FROM applications a
    WHERE a.optimization_id = o.id
  ) as has_application
FROM optimizations o
LEFT JOIN job_descriptions jd ON o.jd_id = jd.id;

CREATE INDEX ON optimization_history_view(user_id, created_at DESC);
```

2. **Refresh Strategy**: Refresh on optimization creation or nightly

### Phase 3: Archive Strategy (Future)
For users with 1,000+ optimizations:
- Implement soft archive (archived_at column)
- Move archived optimizations to separate table
- Provide "View Archived" toggle

## Summary

**Key Decisions**:
- ✅ No schema changes required (use existing tables)
- ✅ Add 3 indexes for performance optimization
- ✅ Client-side search to avoid complex full-text setup
- ✅ Server-side date/score filters for efficiency
- ✅ Pagination with reasonable limits (20 default, 100 max)
- ✅ Bulk operations limited to 50 items to prevent abuse

**Performance Confidence**:
- All success criteria (SC-001 through SC-012) are achievable
- Indexes provide 2-5x query speed improvement
- Client-side operations meet <300ms targets
- Pagination prevents large dataset performance issues

**Next Steps**: Proceed to Phase 2 (Task Generation) with data model finalized.
