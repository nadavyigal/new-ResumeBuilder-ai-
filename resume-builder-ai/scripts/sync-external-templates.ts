#!/usr/bin/env node
/**
 * Template Sync Script
 *
 * Copies React templates from external library (resume-style-bank) to project
 * and generates auto-registry for dynamic imports
 *
 * Source: C:\Users\nadav\OneDrive\◊û◊°◊û◊õ◊ô◊ù\AI\cursor\cursor playground\AI Travel Club\resume-style-bank\react
 * Target: resume-builder-ai/src/lib/templates/external/
 *
 * Reference: research.md Step 1 implementation
 */

import * as fs from 'fs-extra';
import * as path from 'path';

// Configuration
const EXTERNAL_TEMPLATES_SOURCE = path.resolve(
  'C:\\Users\\nadav\\OneDrive\\◊û◊°◊û◊õ◊ô◊ù\\AI\\cursor\\cursor playground\\AI Travel Club\\resume-style-bank\\react'
);

const TARGET_DIR = path.resolve(__dirname, '../src/lib/templates/external');

const TEMPLATE_SLUGS = ['minimal-ssr', 'card-ssr', 'sidebar-ssr', 'timeline-ssr'];

// Files to include in sync (exclude package.json, render.js)
const INCLUDE_EXTENSIONS = ['.jsx', '.tsx', '.ts', '.js'];
const EXCLUDE_FILES = ['package.json', 'render.js', 'node_modules'];

interface TemplateInfo {
  name: string;
  sourcePath: string;
  targetPath: string;
  files: string[];
}

/**
 * Main sync function
 */
async function syncTemplates(): Promise<void> {
  console.log('üîÑ Starting template sync...\n');

  // Step 1: Validate source directory exists
  if (!fs.existsSync(EXTERNAL_TEMPLATES_SOURCE)) {
    throw new Error(`Source directory not found: ${EXTERNAL_TEMPLATES_SOURCE}`);
  }

  console.log(`üìÇ Source: ${EXTERNAL_TEMPLATES_SOURCE}`);
  console.log(`üìÅ Target: ${TARGET_DIR}\n`);

  // Step 2: Create target directory
  await fs.ensureDir(TARGET_DIR);

  // Step 3: Sync each template
  const templates: TemplateInfo[] = [];

  for (const slug of TEMPLATE_SLUGS) {
    console.log(`üìã Processing template: ${slug}`);

    const sourcePath = path.join(EXTERNAL_TEMPLATES_SOURCE, slug);
    const targetPath = path.join(TARGET_DIR, slug);

    // Validate template exists
    if (!fs.existsSync(sourcePath)) {
      console.warn(`‚ö†Ô∏è  Template not found: ${sourcePath}. Skipping.`);
      continue;
    }

    // Create target subdirectory
    await fs.ensureDir(targetPath);

    // Copy template files
    const files = await copyTemplateFiles(sourcePath, targetPath, slug);

    templates.push({
      slug,
      name: slugToName(slug),
      sourcePath,
      targetPath,
      files
    });

    console.log(`‚úÖ Synced ${files.length} files for ${slug}\n`);
  }

  // Step 4: Generate auto-registry
  await generateRegistry(templates);

  console.log(`\n‚ú® Template sync complete! ${templates.length} templates synced.`);
}

/**
 * Copy template files from source to target
 */
async function copyTemplateFiles(
  sourcePath: string,
  targetPath: string,
  slug: string
): Promise<string[]> {
  const files = await fs.readdir(sourcePath);
  const copiedFiles: string[] = [];

  for (const file of files) {
    // Skip excluded files
    if (EXCLUDE_FILES.includes(file)) {
      continue;
    }

    const sourceFile = path.join(sourcePath, file);
    const targetFile = path.join(targetPath, file);

    // Only copy files with allowed extensions
    const ext = path.extname(file);
    if (INCLUDE_EXTENSIONS.includes(ext)) {
      await fs.copy(sourceFile, targetFile, { overwrite: true });
      copiedFiles.push(file);
      console.log(`  üìÑ Copied: ${file}`);
    }
  }

  return copiedFiles;
}

/**
 * Generate auto-registry file with template imports
 */
async function generateRegistry(templates: TemplateInfo[]): Promise<void> {
  console.log('\nüìù Generating template registry...');

  const registryPath = path.join(TARGET_DIR, 'index.ts');

  const imports = templates
    .map((t) => `import ${slugToPascalCase(t.slug)} from './${t.slug}/Resume';`)
    .join('\n');

  const registry = templates
    .map((t) => `  '${t.slug}': ${slugToPascalCase(t.slug)}`)
    .join(',\n');

  const content = `/**
 * Auto-generated Template Registry
 * Generated by: scripts/sync-external-templates.ts
 * Last Updated: ${new Date().toISOString()}
 *
 * DO NOT EDIT MANUALLY - Changes will be overwritten on next sync
 */

${imports}

export interface TemplateComponent {
  (props: any): JSX.Element;
}

export const TEMPLATE_REGISTRY: Record<string, TemplateComponent> = {
${registry}
};

export function getExternalTemplate(templateId: string): TemplateComponent | null {
  return TEMPLATE_REGISTRY[templateId] || null;
}

export function listExternalTemplates(): string[] {
  return Object.keys(TEMPLATE_REGISTRY);
}

export default TEMPLATE_REGISTRY;
`;

  await fs.writeFile(registryPath, content, 'utf-8');
  console.log(`‚úÖ Registry generated: ${registryPath}`);
}

/**
 * Convert slug to human-readable name
 */
function slugToName(slug: string): string {
  return slug
    .split('-')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

/**
 * Convert slug to PascalCase for component name
 */
function slugToPascalCase(slug: string): string {
  return slug
    .split('-')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

// Execute sync
if (require.main === module) {
  syncTemplates()
    .then(() => {
      console.log('\n‚úÖ Template sync completed successfully!');
      process.exit(0);
    })
    .catch((error) => {
      console.error('\n‚ùå Template sync failed:', error);
      process.exit(1);
    });
}

export { syncTemplates };
